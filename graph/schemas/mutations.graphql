type Mutation {
    # Create and send a new OTP
    # expireTime is expresend in seconds
    requestOTP(type: DeliveryMode!, target: String!, expireTimeInSeconds: Int): Response!
    # Verify an OTP
    verifyOTP(target: String!, otpToken: String!): Response!
    # Creates a new ROAVA customer
    signup(customer: CustomerInput!): AuthResponse!
    # Reset a customer login password (OTP required)
    resetLoginPassword(otpToken: String!, email: String!, loginPassword: String!): Response!
    # Returns valid response and code depending of type of user (0 - Customer exist, 1 - Customer exist and has GBP account)
    checkCustomerEmail(email: String!, device: DeviceInput!): Response!
    # Validates customer data in order to proced with secure actions
    checkCustomerData(customerData: CheckCustomerDataInput!): Response!
    # Register for the fist time the details of the customer logged in
    register(customerDetails: CustomerDetailsInput!): Response!
    # Submit a CDD for a given customer
    submitCDD(cdd: CDDInput!): Response!
    # Creates a questionaryAnswer model for the current customer
    answerQuestionary(questionary: QuestionaryAnswerInput!): Response!
    # Creates a acceptance model for the current customer linked to the content requested
    acceptContent(contentId: String!): Response!
    # Creates a new transaction password (Only if customer doesn't set it up yet)
    setTransactionPassword(password: String!): Response!
    # Reset a customer transaction Password (OTP required)
    resetTransactionPassword(otpToken: String!, email: String!, newTransactionPassword: String!, currentTransactionPassword: String!): Response!
    # Generates a valid jwt token for the customer
    login(credentials: AuthInput!): AuthResponse!
    # Refresh the auth jwt token for the customer
    refreshToken(token: String!): AuthResponse!
    # Create|Updates the device token(s) given
    setDeviceToken(tokens: [DeviceTokenInput]!): Response!
    # Create|Update the device preference(s) given
    setDevicePreferences(preferences: [DevicePreferencesInput!]): Response!
    # Validate customer's BVN
    checkBVN(bvn: String!, phone: String!): Response!
    # Create account of type CURRENT_ACCOUNT product
    createAccount(account: AccountInput!): Response!
    # Create and fund account of type FIXED_DEPOSIT product
    createVaultAccount(account: VaultAccountInput!, transactionPassword: String!): Response!
    # Create a new Beneficiary
    createBeneficiary(beneficiary: BeneficiaryInput!, transactionPassword: String!): Response!
    # Add new account to existing beneficiary
    addBeneficiaryAccount(beneficiaryId: ID!, account: BeneficiaryAccountInput!, transactionPassword: String!): Response!
    # Delete an account from an existing beneficiary
    deleteBeneficaryAccount(beneficiaryId: ID!, accountId: ID!, transactionPassword: String!): Response!
    # Create a new transfer to a beneficiary account
    createTransfer(transfer: TransactionInput!, transactionPassword: String!): Response!

    # ---- Dashboard -----
    # Ask for a customer to resubmit a report
    requestResubmit(customerId: String!, reportIds: [String!], message: String): Response!
    # Generates a valid jwt token for the staff member
    staffLogin(token: String!, authType: AuthType!): AuthResponse!
    # Update KYC status
    updateKYCStatus(id: ID!, status: KYCStatuses!,  message: String!): Response!
    # Update AML status
    updateAMLStatus(id: ID!, status: AMLStatuses!,  message: String!): Response!
}

# API response interface
interface GraphQLResponse {
    # Response message
    message: String
    # Boolean to represent if a response is a success
    success: Boolean!
    # Response code
    code: Int!
}

# API response result
type Response implements GraphQLResponse {
    # Response message
    message: String
    # Boolean to represent if a response is a success
    success: Boolean!
    # Response code
    code: Int!
}

# API response with token
type TokenResponse implements GraphQLResponse{
    # Response message
    message: String
    # Boolean to represent if a response is a success
    success: Boolean!
    # Response code
    code: Int!
    # Token requested
    token: String!
}

type AuthResponse implements GraphQLResponse {
    # Response message
    message: String
    # Boolean to represent if a response is a success
    success: Boolean!
    # Response code
    code: Int!
    # Authentication tokens
    tokens: AuthTokens!
}

type AuthTokens {
    # JWT token
    auth: String!
    # Token to refresh the JWT token
    refresh: String
}


input CustomerInput {
    phone: String!
    email: String!
    loginPassword: String!
    device: DeviceInput
}

input DeviceInput {
    identifier: String!
    os: String!
    brand: String!
    tokens: [DeviceTokenInput!]
    preferences: [DevicePreferencesInput!]
}

input DeviceTokenInput {
    type: DeviceTokenTypes!
    value: String!
}

input DevicePreferencesInput {
    type: DevicePreferencesTypes!
    value: String!
}

input CustomerDetailsInput {
    firstName: String!
    lastName: String!
    dob: Date!
    address: AddressInput!
}

input AddressInput {
    countryId: ID!
    state: String
    city: String
    street: String!
    postcode: String!
    cordinates: CordinatesInput
}

input CordinatesInput {
    latitude: Float!
    longitude: Float!
}

input QuestionaryAnswerInput {
    id: ID!
    """
    An array of the responses for the questions related to current questionary.
    """
    answers: [AnswerInput!]!
}

input AnswerInput {
    id: ID!
    answer: String
    """
    An array of IDs of the predefined answers chosen.
    """
    predefinedAnswers: [ID!]
}

input CDDInput {
    kyc: KYCInput
    aml: Boolean!
    poa: POAInput
}

input KYCInput {
    reportTypes: [KYCTypes!]!
}

input POAInput {
    data: String!
}

input AuthInput {
    # User email to use in the auth
    email: String!
    # Customer login password
    password: String!
    # The device identifier of the customer
    deviceIdentifier: String!
}

input CheckCustomerDataInput {
    email: String!
    firstName: String!
    lastName: String!
    dob: String!
    accountNumber: String!
    sortCode: String!
    deviceIdentifier: String!
}

input AccountInput {
    productId: ID!
}

input VaultAccountInput {
    productId: ID!
    sourceAccount: ID!
    amount: Float!
    name: String
}

input BeneficiaryInput {
    name: String!
    account: BeneficiaryAccountInput!
}

input BeneficiaryAccountInput {
    name: String
    currencyId: ID!
    accountNumber: String!
    code: String!
}

input TransactionInput {
    transactionTypeId: ID!
    reference: String
    feeIds: [ID!]
    exchangeRateId: ID
    amount: Float!
    sourceAccountId: ID!
    targetAccountId: ID!
    idempotencyKey: String!
}

enum AuthType {
    GOOGLE
}

# OTP delivery modes supported
enum DeliveryMode {
    EMAIL
    SMS
    PUSH
}